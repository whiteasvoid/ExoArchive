import unittest
import os
import json
import time
from unittest.mock import patch, mock_open, MagicMock

# Ensure src is in path for direct script execution (if not using pytest/unittest discovery from root)
import sys
if os.path.join(os.getcwd(), 'src') not in sys.path and os.path.join(os.getcwd(), '..', 'src') not in sys.path :
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))


# Temporarily set a test key for Fernet before importing token_manager
# In a real test suite, this might be handled by a test-specific config or fixture.
TEST_ENCRYPTION_KEY = "test_fernet_key_32_bytes_long_123=" # Example, must be 32 url-safe base64-encoded bytes
# A real key can be generated by: from cryptography.fernet import Fernet; Fernet.generate_key().decode()
# For this test, we'll mock Fernet itself to avoid dealing with actual key generation/validation complexities here.

# Mock Fernet before importing token_manager
mock_fernet_instance = MagicMock()
mock_fernet_instance.encrypt.side_effect = lambda data: b"encrypted_" + data
mock_fernet_instance.decrypt.side_effect = lambda data: data.replace(b"encrypted_", b"")

@patch('cryptography.fernet.Fernet', return_value=mock_fernet_instance)
class TestTokenManager(unittest.TestCase):

    def setUp(self):
        # This import must happen *after* Fernet is mocked if we want to control its behavior globally for the module
        from src.auth import token_manager
        self.token_manager = token_manager
        self.token_manager.TOKEN_FILE = "test_bungie_tokens.json.encrypted"
        # Clear any existing test token file
        if os.path.exists(self.token_manager.TOKEN_FILE):
            os.remove(self.token_manager.TOKEN_FILE)

    def tearDown(self):
        # Clean up the test token file after each test
        if os.path.exists(self.token_manager.TOKEN_FILE):
            os.remove(self.token_manager.TOKEN_FILE)

    def test_01_save_and_load_tokens(self, mock_fernet_class):
        """Test saving and then loading tokens."""
        sample_token_info = {
            "access_token": "test_access_token",
            "token_type": "Bearer",
            "expires_in": 3600,
            "refresh_token": "test_refresh_token",
            "membership_id": "12345"
        }
        
        # Mock open for saving
        with patch('builtins.open', mock_open()) as mocked_file_save:
            self.token_manager.save_tokens(sample_token_info)
            # Check if Fernet().encrypt was called
            mock_fernet_instance.encrypt.assert_called_once()
            # Check if file was written in binary mode
            mocked_file_save.assert_called_with(self.token_manager.TOKEN_FILE, "wb")

        # Actual save for subsequent load test
        self.token_manager.save_tokens(sample_token_info)
        self.assertTrue(os.path.exists(self.token_manager.TOKEN_FILE))

        # Mock open for loading
        # We need to provide the content that would have been written by the real save_tokens
        encrypted_content = b"encrypted_" + json.dumps({**sample_token_info, 'received_at': time.time()}).encode()
        
        with patch('builtins.open', mock_open(read_data=encrypted_content)) as mocked_file_load:
            loaded_tokens = self.token_manager.load_tokens()
            mock_fernet_instance.decrypt.assert_called_with(encrypted_content)
            mocked_file_load.assert_called_with(self.token_manager.TOKEN_FILE, "rb")

            self.assertIsNotNone(loaded_tokens)
            self.assertEqual(loaded_tokens["access_token"], sample_token_info["access_token"])
            self.assertEqual(loaded_tokens["membership_id"], sample_token_info["membership_id"])
            self.assertIn("received_at", loaded_tokens)


    def test_02_load_tokens_file_not_exist(self, mock_fernet_class):
        """Test loading tokens when the token file does not exist."""
        self.assertIsNone(self.token_manager.load_tokens())

    def test_03_is_access_token_expired(self, mock_fernet_class):
        """Test token expiration logic."""
        current_time = time.time()
        
        # Token that is not expired
        valid_token_info = {
            "access_token": "valid_token",
            "expires_in": 3600, # 1 hour
            "received_at": current_time - 1800 # Received 30 mins ago
        }
        self.assertFalse(self.token_manager.is_access_token_expired(valid_token_info))

        # Token that is expired (expires_in is small, received_at is old)
        expired_token_info = {
            "access_token": "expired_token",
            "expires_in": 60, # 1 minute
            "received_at": current_time - 3600 # Received 1 hour ago
        }
        self.assertTrue(self.token_manager.is_access_token_expired(expired_token_info))

        # Token that is just about to expire (within the 60s buffer)
        almost_expired_token_info = {
            "access_token": "almost_expired",
            "expires_in": 30, # Expires in 30 seconds
            "received_at": current_time 
        }
        self.assertTrue(self.token_manager.is_access_token_expired(almost_expired_token_info))
        
        # Token missing 'received_at' should be considered expired
        missing_info_token = {"access_token": "token", "expires_in": 3600}
        self.assertTrue(self.token_manager.is_access_token_expired(missing_info_token))

    def test_04_get_access_token_valid(self, mock_fernet_class):
        """Test get_access_token when a valid token exists."""
        token_info = {
            "access_token": "valid_access_token",
            "expires_in": 3600,
            "received_at": time.time()
        }
        # Simulate saved token by patching load_tokens
        with patch.object(self.token_manager, 'load_tokens', return_value=token_info):
            self.assertEqual(self.token_manager.get_access_token(), "valid_access_token")

    def test_05_get_access_token_expired(self, mock_fernet_class):
        """Test get_access_token when an expired token exists (and no refresh logic for now)."""
        token_info = {
            "access_token": "expired_access_token",
            "expires_in": 60,
            "received_at": time.time() - 3600 # Expired an hour ago
        }
        with patch.object(self.token_manager, 'load_tokens', return_value=token_info):
            self.assertIsNone(self.token_manager.get_access_token()) # Expect None as refresh isn't fully mocked here

    def test_06_get_membership_id(self, mock_fernet_class):
        """Test retrieving membership ID."""
        token_info = {
            "membership_id": "98765",
            "access_token": "some_token",
            "expires_in": 3600,
            "received_at": time.time()
        }
        with patch.object(self.token_manager, 'load_tokens', return_value=token_info):
            self.assertEqual(self.token_manager.get_membership_id(), "98765")

    def test_07_clear_tokens(self, mock_fernet_class):
        """Test clearing stored tokens."""
        # First, save a dummy token file
        with open(self.token_manager.TOKEN_FILE, "w") as f:
            f.write("dummy_encrypted_data")
        self.assertTrue(os.path.exists(self.token_manager.TOKEN_FILE))
        
        self.token_manager.clear_tokens()
        self.assertFalse(os.path.exists(self.token_manager.TOKEN_FILE))

if __name__ == '__main__':
    # This allows running the tests directly with `python test/test_token_manager.py`
    # However, it's better to use `python -m unittest discover -s test` from the root directory.
    
    # If running directly, need to adjust sys.path for imports from src
    # This is a simplified version of what's at the top of the file.
    if os.path.abspath(os.path.join(os.path.dirname(__file__), '..')) not in sys.path:
         sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
    
    # Ensure src.auth can be found
    grandparent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
    if grandparent_dir not in sys.path:
        sys.path.insert(0, grandparent_dir)

    unittest.main()
